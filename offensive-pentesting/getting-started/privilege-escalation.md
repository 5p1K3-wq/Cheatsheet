# Privilege Escalation

Наш первоначальный доступ к удаленному серверу обычно осуществляется пользователем с низкими привилегиями, что не дает нам полного доступа через компьютер. Чтобы получить полный доступ, нам нужно будет найти внутреннюю / локальную уязвимость, которая повысит наши привилегии до пользователя root в Linux или администратора / пользователя SYSTEM в Windows. Давайте рассмотрим некоторые общие методы повышения наших привилегий.

## PrivEsc Checklists

Как только мы получим начальный доступ к ящику, мы хотим тщательно перечислить ящик, чтобы найти любые потенциальные уязвимости, которые мы можем использовать для достижения более высокого уровня привилегий. Мы можем найти в Интернете множество контрольных списков и шпаргалок, в которых есть набор проверок, которые мы можем запустить, и команды для выполнения этих проверок. Отличный ресурс - [HackTricks](https://book.hacktricks.xyz/), в котором есть отличный контрольный список для локального повышения привилегий как в [Linux](https://book.hacktricks.xyz/linux-unix/linux-privilege-escalation-checklist), так и в [Windows](https://book.hacktricks.xyz/windows/checklist-windows-privilege-escalation). Еще один отличный репозиторий - [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings), в котором также есть контрольные списки для [Linux](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Linux%20-%20Privilege%20Escalation.md) и [Windows](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Methodology%20and%20Resources/Windows%20-%20Privilege%20Escalation.md). Мы должны начать экспериментировать с различными командами и методами и познакомиться с ними, чтобы понять многочисленные слабые места, которые могут привести к повышению наших привилегий.

## Enumeration Scripts

Многие из вышеперечисленных команд могут автоматически запускаться со сценарием для просмотра отчета и поиска слабых мест. Мы можем запустить множество скриптов для автоматического перечисления сервера, выполнив общие команды, которые возвращают любые интересные результаты. Некоторые из распространенных скриптов перечисления Linux включают [LinEnum](https://github.com/rebootuser/LinEnum.git) и [linuxprivchecker](https://github.com/sleventyeleven/linuxprivchecker), а для Windows включают [Seatbelt](https://github.com/GhostPack/Seatbelt) и [JAWS](https://github.com/411Hall/JAWS).

Еще один полезный инструмент, который мы можем использовать для перечисления серверов, - это [Privilege Escalation Awesome Scripts SUITE \(PEASS\)](https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite), поскольку он поддерживается в актуальном состоянии и включает сценарии для перечисления как Linux, так и Windows.

{% hint style="info" %}
Эти сценарии будут запускать множество команд, известных для выявления уязвимостей, и создавать много «шума», который может запускать антивирусное программное обеспечение или программное обеспечение для мониторинга безопасности, которое ищет эти типы событий. Это может помешать запуску сценариев или даже вызвать тревогу о взломе системы. В некоторых случаях мы можем захотеть выполнить перечисление вручную вместо запуска скриптов.
{% endhint %}

Давайте возьмем пример запуска Linux-скрипта из PEASS под названием LinPEAS:

```bash
spike@htb[/htb]$ ./linpeas.sh
...SNIP...

Linux Privesc Checklist: https://book.hacktricks.xyz/linux-unix/linux-privilege-escalation-checklist
 LEYEND:
  RED/YELLOW: 99% a PE vector
  RED: You must take a look at it
  LightCyan: Users with console
  Blue: Users without console & mounted devs
  Green: Common things (users, groups, SUID/SGID, mounts, .sh scripts, cronjobs)
  LightMangenta: Your username


====================================( Basic information )=====================================
OS: Linux version 3.9.0-73-generic
User & Groups: uid=33(www-data) gid=33(www-data) groups=33(www-data)
...SNIP...
```

Как мы видим, после запуска скрипт начинает собирать информацию и отображать ее в отличном отчете. Давайте обсудим некоторые уязвимости, которые мы должны искать в выходных данных этих скриптов.

## Kernel Exploits

Всякий раз, когда мы сталкиваемся с сервером под управлением старой операционной системы, мы должны начать с поиска потенциальных уязвимостей ядра, которые могут существовать. Предположим, на сервере не установлены последние обновления и исправления. В этом случае он, вероятно, уязвим для определенных эксплойтов ядра, обнаруженных в непропатченных версиях Linux и Windows.

Например, приведенный выше сценарий показал нам версию Linux 3.9.0-73-generic. Если мы используем эксплойты для этой версии в Google или используем searchsploit, мы найдем CVE-2016-5195, также известную как DirtyCow. Мы можем найти и загрузить эксплойт DirtyCow и запустить его на сервере, чтобы получить root-доступ.

Та же концепция применима и к Windows, поскольку в незащищенных / более старых версиях Windows есть множество уязвимостей, которые можно использовать для повышения привилегий. Мы должны помнить, что эксплойты ядра могут вызвать нестабильность системы, и мы должны быть очень осторожны, прежде чем запускать их в производственных системах. Лучше всего опробовать их в лабораторной среде и запускать в производственных системах только с явным одобрением и согласованием с нашим клиентом.

## Vulnerable Software

Еще нам следует обратить внимание на установленное программное обеспечение. Например, мы можем использовать команду `dpkg -l` в Linux или посмотреть `C:\Program Files` в Windows, чтобы узнать, какое программное обеспечение установлено в системе. Мы должны искать общедоступные эксплойты для любого установленного программного обеспечения, особенно если используются какие-либо старые версии, содержащие незащищенные уязвимости.

## User Privileges

Еще один важный аспект, на который следует обратить внимание после получения доступа к серверу, - это привилегии, доступные пользователю, к которому у нас есть доступ. Предположим, нам разрешено запускать определенные команды как root \(или как другой пользователь\). В этом случае мы можем расширить наши привилегии до пользователей root / system или получить доступ в качестве другого пользователя. Ниже приведены некоторые распространенные способы использования определенных привилегий пользователя:

1. Sudo
2. SUID
3. Windows Token Privileges

Команда sudo в Linux позволяет пользователю выполнять команды от имени другого пользователя. Обычно он используется, чтобы позволить пользователям с более низкими привилегиями выполнять команды от имени пользователя root без предоставления им доступа к пользователю root. Обычно это делается, поскольку определенные команды могут запускаться только от имени пользователя root, например tcpdump, или разрешать пользователю доступ к определенным каталогам только с правами root. Мы можем проверить, какие у нас есть привилегии sudo, с помощью команды sudo -l:

```bash
spike@htb[/htb]$ sudo -l

[sudo] password for user1:
...SNIP...

User user1 may run the following commands on ExampleServer:
    (ALL : ALL) ALL
```

Приведенный выше вывод говорит, что мы можем запускать все команды с помощью sudo, что дает нам полный доступ, и мы можем использовать команду su с sudo для переключения на пользователя root:

```bash
spike@htb[/htb]$ sudo su -

[sudo] password for user1:
whoami
root
```

Приведенная выше команда требует пароля для запуска любых команд с помощью sudo. В определенных случаях нам может быть разрешено запускать определенные приложения или все приложения без необходимости предоставления пароля:

```bash
spike@htb[/htb]$ sudo -l

    (user : user) NOPASSWD: /bin/echo
```

Запись NOPASSWD показывает, что команду / bin / echo можно выполнять без пароля. Это было бы полезно, если бы мы получили доступ к серверу через уязвимость и не знали пароля пользователя. Как говорит пользователь, мы можем запускать sudo от имени этого пользователя, а не от имени пользователя root. Для этого мы можем указать пользователя с помощью -u user:

```bash
spike@htb[/htb]$ sudo -u user /bin/echo Hello World!

    Hello World!
```

Как только мы найдем конкретное приложение, которое можно запустить с помощью sudo, мы сможем найти способы его использования, чтобы получить оболочку в качестве пользователя root. [GTFOBins](https://gtfobins.github.io/) содержит список команд и способы их использования с помощью sudo. Мы можем найти приложение, для которого у нас есть привилегия sudo, и если оно существует, оно может сообщить нам точную команду, которую мы должны выполнить, чтобы получить root-доступ, используя имеющуюся привилегию sudo.

[LOLBAS](https://lolbas-project.github.io/#) также содержит список приложений Windows, которые мы можем использовать для выполнения определенных функций, таких как загрузка файлов или выполнение команд в контексте привилегированного пользователя.

## Scheduled Tasks

Как в Linux, так и в Windows существуют методы, позволяющие запускать сценарии через определенные промежутки времени для выполнения задачи. Некоторые примеры - это антивирусное сканирование, выполняющееся каждый час, или сценарий резервного копирования, который запускается каждые 30 минут. Обычно есть два способа воспользоваться преимуществами запланированных задач \(Windows\) или заданий cron \(Linux\) для повышения наших привилегий:

1. Добавить новые запланированные задачи / задания cron
2. Обмануть их, чтобы запустить вредоносное ПО

Самый простой способ - проверить, разрешено ли нам добавлять новые запланированные задачи. В Linux обычная форма поддержки запланированных задач - через Cron Jobs. Существуют определенные каталоги, которые мы можем использовать для добавления новых заданий cron, если у нас есть права на запись для них. Это включает:

1. `/etc/crontab`
2. `/etc/cron.d`
3. `/var/spool/cron/crontabs/root`

Если мы можем писать в каталог, вызываемый заданием cron, мы можем написать сценарий bash с командой обратной оболочки, которая при выполнении должна отправлять нам обратную оболочку.

## Exposed Credentials

Затем мы можем найти файлы, которые мы можем прочитать, и посмотреть, содержат ли они какие-либо открытые учетные данные. Это очень часто встречается с файлами конфигурации, файлами журналов и файлами истории пользователей \(bash\_history в Linux и PSReadLine в Windows\). Сценарии перечисления, которые мы обсуждали в начале, обычно ищут потенциальные пароли в файлах и предоставляют их нам, как показано ниже:

```bash
...SNIP...
[+] Searching passwords in config PHP files
[+] Finding passwords inside logs (limit 70)
...SNIP...
/var/www/html/config.php: $conn = new mysqli(localhost, 'db_user', 'password123');
```

Как мы видим, открыт пароль базы данных password123, что позволит нам войти в локальные базы данных mysql и искать интересную информацию. Мы также можем проверить повторное использование пароля, поскольку пользователь системы мог использовать свой пароль для баз данных, что может позволить нам использовать тот же пароль для переключения на этого пользователя, а именно:

```bash
spike@htb[/htb]$ su -

Password: password123
whoami

root
```

Мы также можем использовать учетные данные пользователя для ssh на сервере в качестве этого пользователя.

## SSH Keys

Наконец, давайте обсудим ключи SSH. Если у нас есть доступ на чтение к каталогу .ssh для определенного пользователя, мы можем прочитать его личные ключи ssh, найденные в /home/user/.ssh/id\_rsa или /root/.ssh/id\_rsa, и использовать их для входа в систему сервер. Если мы можем прочитать каталог /root/.ssh/ и можем прочитать файл id\_rsa, мы можем скопировать его на нашу машину и использовать флаг -i для входа в систему с ним:

```bash
spike@htb[/htb]$ vim id_rsa
spike@htb[/htb]$ chmod 600 id_rsa
spike@htb[/htb]$ ssh user@10.10.10.10 -i id_rsa

root@remotehost#
```

{% hint style="info" %}
Обратите внимание, что мы использовали команду chmod 600 id\_rsa для ключа после того, как создали его на нашей машине, чтобы изменить права доступа к файлу, чтобы они были более строгими. Если ключи ssh имеют слабые разрешения, т.е. могут быть прочитаны другими людьми, сервер ssh не позволит им работать.
{% endhint %}

Если мы обнаружим, что у нас есть доступ на запись к каталогу users / .ssh /, мы можем разместить наш открытый ключ в каталоге ssh пользователя по адресу /home/user/.ssh/authorized\_keys. Этот метод обычно используется для получения доступа по ssh после получения оболочки от имени этого пользователя. Текущая конфигурация SSH не принимает ключи, написанные другими пользователями, поэтому она будет работать только в том случае, если мы уже получили контроль над этим пользователем. Сначала мы должны создать новый ключ с помощью ssh-keygen и флага -f, чтобы указать выходной файл:

```bash
spike@htb[/htb]$ ssh-keygen -f key

Generating public/private rsa key pair.
Enter passphrase (empty for no passphrase): *******
Enter same passphrase again: *******

Your identification has been saved in key
Your public key has been saved in key.pub
The key fingerprint is:
SHA256:...SNIP... user@parrot
The key's randomart image is:
+---[RSA 3072]----+
|   ..o.++.+      |
...SNIP...
|     . ..oo+.    |
+----[SHA256]-----+
```

Это даст нам два файла: key \(который мы будем использовать с ssh -i\) и key.pub, который мы скопируем на удаленную машину. Скопируем key.pub, затем на удаленной машине добавим его в /root/.ssh/authorized\_keys:

```bash
user@remotehost$ echo "ssh-rsa AAAAB...SNIP...M= user@parrot" >> /root/.ssh/authorized_keys
```

Теперь удаленный сервер должен позволить нам войти в систему как этот пользователь, используя наш закрытый ключ:

```bash
spike@htb[/htb]$ ssh root@10.10.10.10 -i key

root@remotehost#
```

Как мы видим, теперь мы можем использовать ssh как пользователь root. [Модули повышения привилегий Linux](https://academy.hackthebox.eu/module/details/51) и [повышения привилегий Windows](https://academy.hackthebox.eu/module/details/67) содержат более подробную информацию о том, как использовать каждый из этих методов для повышения привилегий, а также многие другие.

