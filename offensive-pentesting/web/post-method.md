# POST Method

В отличие от метода GET, POST помещает пользовательские параметры в тело HTTP-запроса. У этого есть три основных преимущества:

* Отсутствие ведения журнала: это может показаться нелогичным, поскольку ведение журнала обычно рассматривается как положительный момент. Однако запросы POST могут обрабатывать такие задачи, как загрузка файлов и вход пользователей в систему. Регистрация этих полей может привести к заполнению локального диска или сохранению паролей в виде открытого текста. Когда вы сталкиваетесь с формой входа в систему, которая принимает вход через запрос GET, это всегда должно быть ВЫСОКОЕ обнаружение, поскольку это, вероятно, приведет к тому, что учетные данные будут сохранены в файлах журнала.
* Меньше требований к кодировке: URL-адреса предназначены для совместного использования, что означает, что они должны подтверждать символы, которые могут быть преобразованы в буквы. Запрос POST помещает данные в тело, которое может принимать двоичные данные. Кодировать нужно только те символы, которые используются для разделения параметров.
* Могут быть отправлены дополнительные данные: максимальная длина URL-адреса зависит от браузеров \(Chrome / Firefox / IE\), веб-серверов \(IIS, Apache, nginx\), сетей доставки контента \(Fastly, Cloudfront, Cloudflare\) и даже для сокращения URL-адресов \(bit.ly , amzn.to\). Как правило, длина URL-адреса не должна превышать 2000 символов.

## Рассмотрение запроса

Давайте рассмотрим простую веб-страницу, которая использует запросы POST для обработки входов в систему. Мы войдем в систему с учетными данными администратора \(admin: password\), а затем изучим, как веб-серверы отслеживают, кто мы. Ниже находится страница входа в систему. Вы можете продолжить, создав цель в конце этого раздела. Учетные данные для цели - guest/guest, потому что вам нужно будет проверить файл cookie для эскалации и эскалации до администратора.

![](../../.gitbook/assets/image%20%2840%29.png)

Мы можем войти в приложение с помощью admin: password или guest: guest. Если мы хотим выйти из веб-сайта, мы можем либо найти кнопку выхода, либо удалить наши файлы cookie, щелкнув значок блокировки, а затем - Очистить файлы cookie и данные сайта. Рекомендуется использовать кнопку выхода на веб-сайтах, потому что это дает веб-серверу уведомление о том, что вы хотите выйти. Удаляя файлы cookie, вы никогда не уведомляете веб-сервер о том, что хотите выйти из системы, и у него не будет возможности прекратить действие ваших файлов cookie. Если ваши файлы cookie были перехвачены, перехвативший их человек будет иметь доступ к вашей учетной записи до тех пор, пока срок их действия не истечет \(обычно 30 дней\).

![](../../.gitbook/assets/image%20%2822%29.png)

Теперь, когда файлы cookie очищены, мы можем снова войти в систему. На этот раз мы включим Burp перед входом в систему, чтобы перехватить учетные данные для входа и просмотреть запрос.

![](../../.gitbook/assets/image%20%2829%29.png)

Мы видим запрос POST к /login.php. Заголовок Content-Type установлен в application / x-www-form-urlencoded, который является типом носителя для данных формы в кодировке URL. Обнаружено, что тело запроса содержит два параметра, то есть имя пользователя и пароль со значениями admin и password.

Нажмите \[Ctrl + R\], чтобы отправить этот запрос в Repeater, и нажмите «Отправить».

![](../../.gitbook/assets/image%20%2838%29.png)

После отправки запроса через Repeater мы видим, что страница возвращает код ответа 302 Found. Мы также видим файл cookie с именем PHPSESSID через заголовок Set-Cookie. Заголовок Location обозначает страницу, на которую мы перенаправляемся. Однако отправка запроса с неправильным паролем приводит к выдаче 200 OK с сообщением «Ошибка входа в систему».

В этом случае из-за имени PHPSESSID очевидно, что файл cookie является «Сеансом», который представляет собой просто уникальную строку символов. Вообще говоря, идентификаторы сеанса почти всегда являются хешами, которые можно идентифицировать по:

* Содержит только шестнадцатеричные символы. \(а-е, 0-9\)
* Быть делимым на 8.

Каждый пользователь приложения имеет уникальный идентификатор сеанса, который сопоставляется либо с файлом, либо с записью в базе данных на сервере, где хранится информация о вашем входе в систему. Не все приложения используют сеансы. Многие фреймворки позволяют пользователю хранить информацию о своем сеансе входа в систему. Это сводит к минимуму вычислительную мощность веб-сервера, поскольку у него больше нет тысяч сеансов, которые нужно отслеживать.

Чтобы сделать это безопасно, веб-сервер должен криптографически подписать запрос и предоставить пользователю хэш данных, которые он хранит. Поскольку пользователь не знает ключ подписи, используемый для создания хэша, он не может изменять данные. Однако, если ключ подписи не используется, пользователь может изменить файл cookie и потенциально обманом заставить сервер предоставить ему больше привилегий, чем предполагалось. При обнаружении файлов cookie, которые вы не узнаете, всегда важно попытаться их декодировать \(base64 / URL и т. д.\) И попытаться изменить их значения.

Давайте сделаем шаг назад и посмотрим, что происходит при неудачном запросе. Ниже приведен снимок экрана, показывающий Burp Repeater с использованием учетных данных admin: test для входа в систему.

![](../../.gitbook/assets/image%20%2818%29.png)

Теперь, когда мы понимаем, что происходит при успешном и неудачном входе в систему. Давайте проверим, что сервер рассматривает нас как неаутентифицированного пользователя после вмешательства в Cookie.

Вернитесь на страницу и войдите в веб-приложение. Вы можете отключить Burpsuite во время входа в систему или просто перенаправить запрос в режиме burp. После входа в систему включите Burp и обновите страницу, чтобы увидеть запрос, отправленный на сервер.

![](../../.gitbook/assets/image%20%2817%29.png)

Мы видим, что запрос отправляется на /admin/dashboard.php вместе с файлом cookie. Мы знаем, что файлы cookie используются для идентификации клиента; что, если мы удалим заголовок cookie? Нажмите \[Ctrl + R\], чтобы отправить его в Repeater, а затем удалите заголовок cookie.

![](../../.gitbook/assets/image%20%2828%29.png)

Выяснилось, что сервер перенаправляет нас обратно на страницу входа. Это потому, что у него не было возможности подтвердить, что мы уже прошли аутентификацию в службе. Нажмите \[Ctrl + Z\], чтобы отменить изменения и сохранить заголовок cookie.

![](../../.gitbook/assets/image%20%2843%29.png)

На этот раз перенаправления не было, и у нас есть доступ к панели администратора.

## Content-Type

Заголовок Content-Type является важной частью запроса POST. Это сообщает веб-серверу, какой тип контента ожидать. В наших примерах выше он был установлен как application / x-www-form-urlencoded. Это говорит серверу ожидать чего-то вроде: ParamName1 = Value1 & ParamName2 = Value.

Есть много других типов контента. Другой популярный - application / json, который используется для ресурсов [JSON](https://en.wikipedia.org/wiki/JSON). Нотация объектов JSON или JavaScript - это упрощенный способ хранения и передачи данных, который легко интерпретировать и анализировать. Объект JSON состоит из пар данных-значений, заключенных в фигурные скобки.

Например:

```bash
{ "name1" : "value1", "name2" : "value2" }
```

Множественные библиотеки и приложения поддерживают ввод JSON, включая веб-приложения. Часто можно изменить Content-Type и заставить приложения анализировать входные данные в разных форматах.

Давайте перехватим запрос к странице входа и попробуем отправить следующий ввод JSON.

```bash
{ "username" : "admin", "password" : "password" }
```

Заголовок Content-Type следует изменить на application / json, чтобы сервер распознал его как JSON.

![](../../.gitbook/assets/image%20%2830%29.png)

Мы видим, что сервер успешно принял учетные данные и перенаправляет нас на панель управления.

Также видно, что установка Content-Type на application / x-www-form-urlencoded не приводит к успешной аутентификации. Это связано с тем, что сервер предполагает, что входные данные являются данными формы, хотя на самом деле это JSON.

![](../../.gitbook/assets/image%20%2826%29.png)

Переключение между URLEncoded и JSON может показаться бессмысленным, но изменение форматов может привести к ситуациям, которых разработчик не ожидал. Многие платформы изначально поддерживают JSON из-за наличия REST API, который используется, когда компьютер связывается с веб-сервером, а не с пользователем. В программировании JSON - широко используемый формат для безопасного хранения объектов.

Примером этого является выполнение SQL-инъекции в базе данных MongoDB. Чтобы выполнить инъекцию, злоумышленник должен отправить массив. Пример того, как сделать это с application / x-www-form-urlencoded: username = admin & password \[$ ge\] = 0, будет пытаться сообщить серверу, что мое имя пользователя - admin, а пароль больше 0. Многие веб-серверы не будут обрабатывать запрос, потому что использование скобок в имени переменной не является обычным явлением. Однако в REST API массивы являются обычным явлением и не будут блокироваться фреймворком. Изменение запроса на:

```bash
{ "username" : "admin", "password" : {"$ge":"0"} }
```

допустит инъекцию, если проявитель не защитил от нее. Модификация Content-Type может сыграть решающую роль в обнаружении уязвимостей и возникновении непреднамеренных ошибок в веб-приложениях. Однако обработка различных типов мультимедиа зависит исключительно от логики приложения и его ожиданий.

